# 1. 演示如何使用Pydantic 告知LLM所需的输出格式。
# Why Pydantic？
# Pydantic可以让一个类自动把自己所需的格式，以json的形式反向放到提示词中，保证LLM输出的结果一定能被正确解析。

from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field, field_validator
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts import PromptTemplate
from dotenv import load_dotenv, find_dotenv

# Load environment variables
load_dotenv(find_dotenv())

# Initialize ChatOpenAI model with desired parameters
model = ChatOpenAI(model="gpt-4o-mini")
# model = ChatOpenAI(temperature=0, model="gpt-4o")

# Define the data structure for the couplet response
class Couplet(BaseModel):
    upper_part: str = Field(description="对联的上联, 7-15个字")
    lower_part: str = Field(description="对联的下联，字数和上联一样多")
    horizontal_part: str = Field(description="对联的横批，一般4个字")

    # Field validator for the upper part of the couplet
    @field_validator("upper_part", mode="before")
    def upper_part_must_not_be_empty(cls, value):
        if not value:
            raise ValueError("上联不能为空")
        # check the length of the upper part. Should be between 7 and 15 characters
        if not 7 <= len(value) <= 15:
            raise ValueError("上联的字数必须在7-15之间")
        return value

    # Field validator for the lower part of the couplet
    @field_validator("lower_part", mode="before")
    def lower_part_must_not_be_empty_and_match_upper(cls, value, info):
        if not value:
            raise ValueError("下联不能为空")
        
        upper_part = info.data.get("upper_part")
        if upper_part and len(value) != len(upper_part):
            raise ValueError(f"下联的长度必须和上联相同。当前上联：{upper_part}，下联：{value}")
        return value

    # Field validator for the horizontal part of the couplet
    @field_validator("horizontal_part", mode="before")
    def horizontal_part_must_be_four_chars(cls, value):
        required_length = 4  # Change to 5 if required
        if not value:
            raise ValueError("横批不能为空")
        if len(value) != required_length:
            raise ValueError(f"横批的长度必须为{required_length}个字")
        return value

# Define the prompt with background instructions and format
couplet_rule_text = """
你是一个专业对联作家。你按照如下的规律编写对联：
1. 理解用户提出的主题
2. 尝试写出一副对联
3. 检查对联是否符合如下的要求：
3.1 上联、下联的字数必须一致
3.2 上联、下联的字数必须在7-15个字之间
3.3 上联、下联的内容必须相关
3.4 上下联的内容尽量对仗，尤其是出现数字时
3.5 上联需要用仄声结尾，下联需要用平声结尾
4. 如果对联不符合要求，重新写一副对联；如果对联符合要求，结束
5. 最多尝试3次，如果3次都不符合要求，给出最后一次的答案，但同时提示用户对联不符合要求
"""

topic = "请写一副蛇年对联。"

# Create a parser to handle the Pydantic structure
parser = PydanticOutputParser(pydantic_object=Couplet)

# Print the format instructions generated by the pydantic object
print(parser.get_format_instructions())

# Set up the prompt template and add instructions
prompt = PromptTemplate(
    template="""
    根据用户提出的主题，为其编写一幅春联。\n
    主题：{topic}\n
    规则：{couplet_rule}\n
    格式：{format_instructions}\n
    """,
    input_variables=["topic"],
    partial_variables={
        "format_instructions": parser.get_format_instructions(),
        "couplet_rule": couplet_rule_text,
    },
)

# Combine the components into a chain
chain = prompt | model | parser

# Run the chain and print the output
try:
    result = chain.invoke({"topic": topic})
    print(result)
except Exception as e:
    print(f"Error: {e}")
